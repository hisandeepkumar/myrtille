<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PDF Signature Adder — List Previews (default_signature.png)</title>

<script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<style>
  *{ box-sizing:border-box; font-family:Inter,system-ui,-apple-system,'Segoe UI',Roboto,Arial; }
  body{ margin:0; padding:18px; background:#071029; color:#e6eef8; display:flex; justify-content:center; }
  .wrapper{ width:100%; max-width:980px; }
  h1{ margin:6px 0 16px; font-size:20px; display:flex; gap:10px; align-items:center; }
  .controls{ display:flex; flex-direction:column; gap:10px; margin-bottom:14px; }
  .upload{ border:2px dashed rgba(255,255,255,0.06); padding:14px; border-radius:10px; cursor:pointer; background:rgba(255,255,255,0.01); position:relative; }
  .file-info, .image-info{ font-weight:600; color:#dbeafe; margin-top:8px; }
  .inputs{ display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
  input[type=range]{ width:220px; }
  button.btn{ margin-top:10px; padding:10px 16px; border-radius:10px; background:#0ea5e9; color:#021026; font-weight:700; border:none; cursor:pointer; }
  button.btn:disabled{ opacity:0.5; cursor:not-allowed; }

  /* PREVIEW list: single column */
  .preview-list{ display:flex; flex-direction:column; gap:18px; max-height:60vh; overflow:auto; padding-right:8px; }
  .preview-item{ background:rgba(255,255,255,0.02); border-radius:10px; padding:12px; position:relative; display:flex; flex-direction:column; align-items:center; }
  .preview-item h3{ margin:0 0 8px; font-size:14px; color:#cfe8ff; }

  /* wrapper around canvas to position signature layer exactly */
  .canvas-wrap{ position:relative; display:inline-block; }
  canvas{ display:block; border-radius:6px; box-shadow:0 6px 20px rgba(0,0,0,0.6); background:white; }

  .sig-layer{ position:absolute; left:0; top:0; pointer-events:auto; }
  .signature{ position:absolute; cursor:move; user-select:none; touch-action:none; display:flex; align-items:center; }
  .signature img{ display:block; width:100px; height:auto; pointer-events:none; opacity:0.95; }
  .delete-btn{ position:absolute; right:-10px; top:-10px; width:26px; height:26px; background:#ef4444; color:white; border-radius:50%; border:none; display:flex; align-items:center; justify-content:center; cursor:pointer; }

  .progress{ height:8px; background:rgba(255,255,255,0.04); border-radius:6px; overflow:hidden; margin-top:10px; display:none; }
  .progress > div{ height:100%; width:0%; background:#60a5fa; transition:width 200ms linear; }

  @media (max-width:760px){
    .inputs{ flex-direction:column; align-items:stretch; }
  }
</style>
</head>
<body>
  <div class="wrapper">
    <h1><i class="fas fa-file-signature" style="color:#60a5fa"></i> PDF Signature Adder — List Previews</h1>

    <div class="controls">
      <div class="upload" id="uploadArea">
        <strong>Click or drag & drop a PDF here</strong>
        <input type="file" id="pdfInput" accept="application/pdf" style="position:absolute; inset:0; opacity:0; cursor:pointer;">
        <div class="file-info" id="fileInfo" style="display:none"></div>
      </div>

      <div class="inputs">
        <div>
          <label style="font-weight:700">Signature Image (optional)</label><br>
          <input type="file" id="sigImage" accept="image/*">
          <div class="image-info" id="imageInfo" style="display:none"></div>
        </div>

        <div>
          <label style="font-weight:700">Signature width (<span id="sizeVal">100</span> px)</label><br>
          <input type="range" id="sizeRange" min="50" max="350" value="100">
        </div>

        <div style="align-self:center">
          <button class="btn" id="generateBtn" disabled><i class="fas fa-download"></i> Generate Signed PDF</button>
        </div>
      </div>

    </div>

    <div class="preview-list" id="previewList"></div>

    <div class="progress" id="progress"><div id="progressBar"></div></div>
  </div>

<script>
(async ()=> {
  const pdfInput = document.getElementById('pdfInput');
  const uploadArea = document.getElementById('uploadArea');
  const fileInfo = document.getElementById('fileInfo');
  const previewList = document.getElementById('previewList');
  const sigImageInput = document.getElementById('sigImage');
  const imageInfo = document.getElementById('imageInfo');
  const sizeRange = document.getElementById('sizeRange');
  const sizeVal = document.getElementById('sizeVal');
  const generateBtn = document.getElementById('generateBtn');
  const progress = document.getElementById('progress');
  const progressBar = document.getElementById('progressBar');

  const DPR = window.devicePixelRatio || 1;
  let selectedPdfFile = null;
  let pdfLibDoc = null;
  let pdfJsDoc = null;
  let selectedImageFile = null;
  let signatureImgUrl = null;
  let signatureWidth = parseInt(sizeRange.value,10);
  let pageData = []; // per page: {pdfSize:{w,h}, viewport:{w,h}, canvasSize:{cssW,cssH}, signatures:[{id,x_pdf,top_pdf,visualWidth}]}

  // inline fallback SVG (used only if default_signature.png not found and user didn't upload)
  const FALLBACK_SIG = `data:image/svg+xml;base64,${btoa(
    `<svg xmlns='http://www.w3.org/2000/svg' width='400' height='140'>
      <path d='M10 90 C 60 10, 140 10, 190 90 S 330 170, 390 90' stroke='#0b1220' stroke-width='6' fill='none' stroke-linecap='round' />
    </svg>`
  )}`;

  function fmt(bytes){
    if(!bytes) return '';
    if(bytes<1024) return bytes + ' B';
    if(bytes<1024*1024) return (bytes/1024).toFixed(2) + ' KB';
    return (bytes/(1024*1024)).toFixed(2) + ' MB';
  }

  // Drag visuals
  ['dragenter','dragover'].forEach(ev => {
    uploadArea.addEventListener(ev, e=>{ e.preventDefault(); uploadArea.style.borderColor='#60a5fa'; });
  });
  ['dragleave','drop'].forEach(ev => {
    uploadArea.addEventListener(ev, e=>{ e.preventDefault(); uploadArea.style.borderColor=''; });
  });
  uploadArea.addEventListener('drop', e=> {
    if(e.dataTransfer?.files?.length) handlePdf(e.dataTransfer.files[0]);
  });
  uploadArea.addEventListener('click', ()=> pdfInput.click());
  pdfInput.addEventListener('change', e=> { if(e.target.files?.length) handlePdf(e.target.files[0]); });

  sigImageInput.addEventListener('change', e=>{
    if(!e.target.files?.length) return;
    const f = e.target.files[0];
    if(!f.type.startsWith('image/')) { alert('Select an image file (PNG/JPEG/SVG)'); return; }
    selectedImageFile = f;
    signatureImgUrl = URL.createObjectURL(f);
    imageInfo.style.display='block';
    imageInfo.textContent = `Signature: ${f.name} (${fmt(f.size)})`;
    generateBtn.disabled = pageData.every(p=> (p.signatures && p.signatures.length===0));
  });

  sizeRange.addEventListener('input', ()=> {
    signatureWidth = parseInt(sizeRange.value,10);
    sizeVal.textContent = signatureWidth;
    // update visible images
    document.querySelectorAll('.signature img').forEach(img=> img.style.width = `${signatureWidth}px`);
    // update stored visual widths
    pageData.forEach(p => { if(p.signatures) p.signatures.forEach(s=> s.visualWidth = signatureWidth); });
  });

  // Ensure default signature (default_signature.png) is loaded into selectedImageFile if user didn't upload
  async function ensureDefaultSig(){
    if(selectedImageFile) return;
    try {
      const resp = await fetch('default_signature.png', {cache: 'no-store'});
      if(!resp.ok) throw new Error('default_signature.png not found ('+resp.status+')');
      const blob = await resp.blob();
      // convert blob to File so embedding logic later can handle it similarly
      selectedImageFile = new File([blob], 'default_signature.png', { type: blob.type });
      signatureImgUrl = URL.createObjectURL(blob);
      imageInfo.style.display='block';
      imageInfo.textContent = `Signature: default_signature.png (${fmt(blob.size)})`;
      console.log('Loaded default_signature.png from same folder.');
    } catch (err){
      console.warn('default_signature.png not found — falling back to inline SVG. Error:', err);
      // fallback to embedded svg data
      const res = await fetch(FALLBACK_SIG);
      const blob = await res.blob();
      selectedImageFile = new File([blob], 'fallback_signature.svg', { type: blob.type });
      signatureImgUrl = URL.createObjectURL(blob);
      imageInfo.style.display='block';
      imageInfo.textContent = `Signature: fallback_signature (inline)`;
    }
  }

  // Handle PDF reading + render previews in LIST form (single column)
  async function handlePdf(file){
    if(!file) return;
    if(file.type !== 'application/pdf'){ alert('Select a PDF'); return; }
    selectedPdfFile = file;
    fileInfo.style.display = 'block';
    fileInfo.textContent = `${file.name} (${fmt(file.size)})`;
    previewList.innerHTML = '';
    pageData = [];
    generateBtn.disabled = true;

    const arr = await file.arrayBuffer();
    pdfLibDoc = await PDFLib.PDFDocument.load(arr);
    pdfJsDoc = await pdfjsLib.getDocument({data:arr}).promise;

    const total = pdfLibDoc.getPageCount();

    // For list previews we fix max display width for each canvas (keeps consistent)
    const MAX_DISPLAY_WIDTH = 740; // css px

    for(let p=1;p<=total;p++){
      const page = await pdfJsDoc.getPage(p);
      // compute scale so that viewport.width fits MAX_DISPLAY_WIDTH (or less)
      const baseViewport = page.getViewport({scale:1});
      const targetScale = Math.min(1.25, Math.max(0.6, MAX_DISPLAY_WIDTH / baseViewport.width));
      const viewport = page.getViewport({scale: targetScale});

      // canvas size for DPR
      const cssW = Math.round(viewport.width);
      const cssH = Math.round(viewport.height);
      const canvas = document.createElement('canvas');
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      canvas.width = Math.floor(cssW * DPR);
      canvas.height = Math.floor(cssH * DPR);
      const ctx = canvas.getContext('2d');
      ctx.setTransform(DPR,0,0,DPR,0,0);
      await page.render({ canvasContext: ctx, viewport }).promise;

      // pdf-lib page size in PDF points
      const libPage = pdfLibDoc.getPage(p-1);
      const psize = libPage.getSize(); // { width, height }

      // create preview item (list-style)
      const item = document.createElement('div');
      item.className = 'preview-item';
      const title = document.createElement('h3');
      title.textContent = `Page ${p}`;
      item.appendChild(title);

      // wrapper to position signature layer exactly over canvas
      const wrap = document.createElement('div');
      wrap.className = 'canvas-wrap';
      wrap.style.width = cssW + 'px';
      wrap.style.height = cssH + 'px';
      wrap.appendChild(canvas);

      // signature transparent layer
      const layer = document.createElement('div');
      layer.className = 'sig-layer';
      layer.style.width = cssW + 'px';
      layer.style.height = cssH + 'px';
      layer.style.left = '0';
      layer.style.top = '0';
      layer.style.pointerEvents = 'auto';
      wrap.appendChild(layer);

      item.appendChild(wrap);
      previewList.appendChild(item);

      // store page meta
      pageData[p-1] = {
        pdfSize: { width: psize.width, height: psize.height }, // pdf points
        viewport: { width: viewport.width, height: viewport.height }, // css px (un-DPR'd)
        canvasSize: { cssWidth: cssW, cssHeight: cssH },
        layerElement: layer,
        wrapElement: wrap,
        signatures: []
      };

      // click to add signature at clicked position (css coordinates)
      layer.addEventListener('click', async (ev)=>{
        await ensureDefaultSig();
        if(!signatureImgUrl){ alert('Signature missing'); return; }

        // compute coordinates relative to layer
        const rect = layer.getBoundingClientRect();
        const clientX = ev.clientX;
        const clientY = ev.clientY;
        const x_css = clientX - rect.left;
        const y_css = clientY - rect.top; // distance from top (css px)

        addSignatureToPage(p-1, x_css, y_css);
      });
    } // end pages loop

    // enable generate only when one or more signatures are present
    generateBtn.disabled = pageData.every(p=> (p.signatures && p.signatures.length===0));
  }

  // add signature DOM and store PDF-mapped coords
  function addSignatureToPage(pageIndex, x_css, y_css){
    const pd = pageData[pageIndex];
    if(!pd) return;
    const layer = pd.layerElement;
    // create DOM signature
    const id = 'sig-'+pageIndex+'-'+Date.now();
    const sig = document.createElement('div');
    sig.className = 'signature';
    sig.id = id;
    // center the image at click point visually
    const left = x_css - (signatureWidth/2);
    const top = y_css - (signatureWidth/2);
    sig.style.left = Math.max(0,left) + 'px';
    sig.style.top = Math.max(0,top) + 'px';
    sig.style.width = signatureWidth + 'px';

    const img = document.createElement('img');
    img.src = signatureImgUrl || FALLBACK_SIG;
    img.style.width = signatureWidth + 'px';
    sig.appendChild(img);

    const del = document.createElement('button');
    del.className = 'delete-btn';
    del.innerHTML = '<i class="fas fa-trash"></i>';
    del.addEventListener('click', (ev)=> {
      ev.stopPropagation();
      sig.remove();
      pd.signatures = pd.signatures.filter(s=> s.id !== id);
      generateBtn.disabled = pd.signatures.every(arr=> arr.length===0) && pageData.every(p=> p.signatures.length===0);
    });
    sig.appendChild(del);

    layer.appendChild(sig);

    // map css coords -> PDF points
    const scaleX = pd.pdfSize.width / pd.viewport.width;
    const scaleY = pd.pdfSize.height / pd.viewport.height;
    const pdfX = (left) * scaleX; // left in PDF points
    const pdfTop = (top) * scaleY; // distance from top in PDF points

    const stored = { id, x_pdf: pdfX, top_pdf: pdfTop, visualWidth: signatureWidth };
    pd.signatures.push(stored);

    // make draggable
    makeDraggable(sig, pageIndex, stored);

    generateBtn.disabled = false;
  }

  function makeDraggable(domEl, pageIndex, stored){
    let dragging = false;
    let startX=0, startY=0, startLeft=0, startTop=0;
    const layer = pageData[pageIndex].layerElement;

    const onDown = (e) => {
      e.preventDefault();
      dragging = true;
      const clientX = e.type.startsWith('touch') ? e.touches[0].clientX : e.clientX;
      const clientY = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;
      startX = clientX; startY = clientY;
      startLeft = parseFloat(domEl.style.left || 0);
      startTop = parseFloat(domEl.style.top || 0);
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
      document.addEventListener('touchmove', onMove, {passive:false});
      document.addEventListener('touchend', onUp);
    };

    const onMove = (e) => {
      if(!dragging) return;
      e.preventDefault();
      const clientX = e.type.startsWith('touch') ? e.touches[0].clientX : e.clientX;
      const clientY = e.type.startsWith('touch') ? e.touches[0].touches ? e.touches[0].clientY : e.touches[0].clientY : e.clientY;
      const dx = clientX - startX;
      const dy = clientY - startY;
      let newLeft = startLeft + dx;
      let newTop = startTop + dy;
      // clamp inside layer
      newLeft = Math.max(0, Math.min(newLeft, layer.clientWidth - domEl.offsetWidth));
      newTop  = Math.max(0, Math.min(newTop, layer.clientHeight - domEl.offsetHeight));
      domEl.style.left = newLeft + 'px';
      domEl.style.top = newTop + 'px';

      // update stored PDF coords
      const pd = pageData[pageIndex];
      const scaleX = pd.pdfSize.width / pd.viewport.width;
      const scaleY = pd.pdfSize.height / pd.viewport.height;
      stored.x_pdf = newLeft * scaleX;
      stored.top_pdf = newTop * scaleY;
      stored.visualWidth = parseFloat(domEl.offsetWidth);
    };

    const onUp = (e) => {
      dragging = false;
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
      document.removeEventListener('touchmove', onMove);
      document.removeEventListener('touchend', onUp);
    };

    domEl.addEventListener('mousedown', onDown);
    domEl.addEventListener('touchstart', onDown, {passive:false});
  }

  // generation
  generateBtn.addEventListener('click', async ()=>{
    if(!selectedPdfFile) { alert('Please upload a PDF'); return; }
    if(pageData.every(p=> p.signatures.length===0)){ alert('Place at least one signature'); return; }
    await ensureDefaultSig();
    try{
      generateBtn.disabled = true;
      progress.style.display='block';
      progressBar.style.width='10%';

      const arr = await selectedPdfFile.arrayBuffer();
      progressBar.style.width='25%';
      const pdfDoc = await PDFLib.PDFDocument.load(arr);
      progressBar.style.width='40%';

      // embed image (handle SVG by rasterizing to PNG)
      const imgBytes = await selectedImageFile.arrayBuffer();
      let embedded;
      if(selectedImageFile.type === 'image/svg+xml' || selectedImageFile.name.endsWith('.svg')){
        // rasterize svg via image->canvas->png
        const svgText = await (new Response(imgBytes)).text();
        const imgEl = new Image();
        const blob = new Blob([svgText], {type:'image/svg+xml'});
        const url = URL.createObjectURL(blob);
        await new Promise((res, rej) => { imgEl.onload = ()=> res(); imgEl.onerror = ()=> rej('SVG load fail'); imgEl.src = url; });
        // draw
        const c = document.createElement('canvas');
        c.width = imgEl.naturalWidth || 400;
        c.height = imgEl.naturalHeight || 150;
        c.getContext('2d').drawImage(imgEl,0,0,c.width,c.height);
        const png = c.toDataURL('image/png');
        const raw = atob(png.split(',')[1]);
        const u8 = new Uint8Array(raw.length);
        for(let i=0;i<raw.length;i++) u8[i]=raw.charCodeAt(i);
        embedded = await pdfDoc.embedPng(u8);
      } else if(selectedImageFile.type === 'image/png') {
        embedded = await pdfDoc.embedPng(imgBytes);
      } else {
        // jpeg fallback
        embedded = await pdfDoc.embedJpg(imgBytes);
      }
      progressBar.style.width='65%';

      const pages = pdfDoc.getPages();
      for(let i=0;i<pages.length;i++){
        const page = pages[i];
        const pd = pageData[i];
        if(!pd) continue;
        for(const s of pd.signatures){
          // compute pdf width based on visualWidth (css px -> pdf pts)
          const pdfW = (s.visualWidth || signatureWidth) * (pd.pdfSize.width / pd.viewport.width);
          const imgW = embedded.width;
          const imgH = embedded.height;
          const pdfH = (pdfW / imgW) * imgH;
          const yBottom = pd.pdfSize.height - s.top_pdf - pdfH;
          page.drawImage(embedded, { x: s.x_pdf, y: yBottom, width: pdfW, height: pdfH, opacity:1 });
        }
      }
      progressBar.style.width='85%';
      const out = await pdfDoc.save();
      progressBar.style.width='95%';

      const blob = new Blob([out], { type:'application/pdf' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `SIGNED_${Date.now()}.pdf`;
      document.body.appendChild(a); a.click(); a.remove();
      progressBar.style.width='100%';
      setTimeout(()=>{ progress.style.display='none'; progressBar.style.width='0%'; },500);
      // reset
      previewList.innerHTML = '';
      selectedPdfFile = null;
      fileInfo.style.display='none';
      imageInfo.style.display='none';
      pageData = [];
      generateBtn.disabled = true;
    }catch(err){
      console.error(err);
      alert('Error: '+(err.message||err));
      generateBtn.disabled = false;
      progress.style.display='none';
      progressBar.style.width='0%';
    }
  });

  // small utility: enable generate button if any signature placed
  const observer = new MutationObserver(()=> {
    generateBtn.disabled = pageData.every(p=> p.signatures.length===0);
  });
  observer.observe(previewList, { childList:true, subtree:true });

})();
</script>
</body>
</html>
